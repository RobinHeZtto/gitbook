---
description: '> HTTP专题01'
---

# HTTP基础

> **目标：**
>
> * 对 HTTP 协议形成一个**整体概念**，明确设计 HTTP 的**目的及意义所在**，了解 HTTP 的**工作机制**。
> * 掌握HTTP报文中常用的**首部字段**，返回结果**状态码**的作用，对客户端与服务器的各种**通信交互细节**做到了然于心，从而在平时的开发工作中**独立思考**，迅速准确地定位分析由 HTTP 引发的问题。

## 1. HTTP相关基础

<div align="center"><img src="../../../.gitbook/assets/image (469).png" alt=""></div>

### 1.1 什么是HTTP？

&#x20;       **超文本传输协议（HyperText Transfer Protocol）**&#x662F;一个用于传输超媒体文档（例如 HTML）的[应用层](https://en.wikipedia.org/wiki/Application_Layer)协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的[客户端-服务端模型](https://en.wikipedia.org/wiki/Client%E2%80%93server_model)，客户端打开一个链接后发出请求，然后等待直到收到服务器端响应。HTTP是[万维网](https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2)的数据通信的基础。

### 1.2 HTTP诞生与演化

#### **1.2.1 诞生**

&#x20;       1989 年 3 月，互联网还只属于少数人，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。

![](<../../../.gitbook/assets/image (418).png>)

* **URI**：即**统一资源标识符**，作为互联网上资源的唯一身份；
* **HTML**：即**超文本标记语言**，把 SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，描述超文本文档）；
* **HTTP**：即**超文本传输协议**，用来传输超文本。

> WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。

**1.2.2 HTTP/0.9**

&#x20;       20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了纯文本格式。蒂姆·伯纳斯 - 李最初设想的系统里的文档都是只读的，所以**只允许用GET**动作从服务器上获取 HTML 文档，并且**在响应请求之后立即关闭连接**，功能非常有限。

&#x20;       HTTP/0.9 虽然很简单，但它作为一&#x4E2A;**“原型”**，充分验证了 Web 服务的可行性，而“简单”也正是它的优点，蕴含了进化和扩展的可能性，因为：“把简单的系统变复杂”，要比“把复杂的系统变简单”容易得多。

> 这个时候HTTP本身没有版本号的，之所以成为HTTP/0.9是后人加上去的，为了区分后面演进的版本。

**1.2.3 HTTP/1.0**:

&#x20;       人们的需求是无止尽的，随着图像和音频的发展，浏览器也在不断的进步予以支持。需求促使添加各种特性来满足用户的需求，这些新软件新技术一经推出立刻就吸引了广大网民的热情，更的多的人开始使用互联网，研究 HTTP 并提出改进意见，甚至实验性地往协议里添加各种特性，**从用户需求的角度促进了 HTTP 的发展**。于是在这些已有实践的基础上，经过一系列的草案，HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和现在的 HTTP 差别不大，例如：

* 增加了 HEAD、POST 等新方法；
* 增加了响应状态码，标记可能的错误原因；
* 在请求中加入了HTTP协议版本号（工程化的象征）；
* 引入了 HTTP Header（头部）的概念，即请求头与响应头，让 HTTP 处理请求和响应更加灵活，把控制数据和业务实体进行了拆分；
* 引入了 Content-Type ，使得传输的数据不再限于文本。

> 此时的HTTP/1.0 还没有标准化，没有实际的约束力，各家公司都有自己的实现标准，比如网景的 Netscape Navigator 和微软的 Internet Explorer 著名的“浏览器大战”，都希望在互联网上占据主导地位。

**1.2.4 HTTP/1.1**

&#x20;       从 1995 年至 1999 年间的第一次浏览器大战，极大的推动了 Web 的发展。随着网络不断发展， HTTP/1.0 演进到了 HTTP/1.1，并于1997年在的 RFC 2068 中首次被记录，此后又在 1999 年废弃了RFC 2068，重新发布了 RFC 2616。

&#x20;       HTTP/1.1 主要的变更点有：

* 增加了 PUT、DELETE 等新的方法；
* 增加了缓存管理和控制；
* 明确了连接管理即keepalive，允许持久连接（在HTTP/0.9及HTTP/1.0版本里面，一个http请求要发送就要先在客户端和服务器端之间创建一个TCP连接，创建完这个TCP连接之后，等服务器端返回完数据之后，这个TCP连接就关闭了。这个成本是相对比较高的，因为在建立一个TCP连接的过程中要进行tcp的三次握手，在创建这个连接的过程中消耗是比较高的，延迟也会比较高。这里的持久连接在建立完一个连接之后，它可以不关闭，之后新的http请求就可以一直在这个连接里面进行数据发送的话，性能和效率提升了很多）；
* 支持 pipeline，无需等待前面的请求响应，即可发送第二次请求。
* 允许响应数据分块（chunked），即响应的时候不标明Content-Length，客户端就无法断开连接，直到收到服务端的 EOF ，利于传输大文件；
* 强制要求 Host 头，让互联网主机托管成为可能（有了host之后就可以在同一台服务器(物理服务器)上同时跑多个web服务。比如说一个Node.js的web服务，一个Java的web服务。通过host这个字段来表示两个服务都是请求到同一个物理服务器上，但是我要请求的是里面哪一个软件服务，Node.js还是Java？这就是通过host来进行判断的。**host头增加的好处就是，在同一个物理服务器或者同一个集群里面可以部署很多不同的web服务来，提高了物理服务器的使用效率**）。

![](<../../../.gitbook/assets/image (432).png>)

> 浏览器大战推进了 Web 的发展，也暴露出 HTTP/1.0 的不足之处，毕竟网络带宽等等都在进步，总不能让协议限制了硬件的发展。因此提出了 HTTP/1.1 ，主要是为了解决性能的问题，包括支持持久连接、pipeline、缓存管理等等，也添加了一些特性。
>
> HTTP/1.1推出后，开启了后续的“Web 1.0”“Web 2.0”时代。现在许多的知名网站都是在这个时间点左右创立的，例如 Google、新浪、搜狐、网易、腾讯等。

#### **1.2.5 HTTP/2**

&#x20;       随着整个互联网世界呈现出了爆发式的增长，度过了十多年的“快乐时光”，涌现出了 Facebook、Twitter、淘宝、京东等互联网新贵。这期间也出现了一些对 HTTP 不满的意见，主要就是**连接慢，无法跟上迅猛发展的互联网**，但 HTTP/1.1 标准一直“岿然不动”，无奈之下人们只好发明各式各样的“小花招”来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段。

&#x20;       这时候 Google 看不下去了，你不搞是吧？我自己搞我的，我自己和我自己玩，我用户群体大，我有 Chrome，我服务多了去了。Google 推出了**SPDY 协议**，凭借着它全球的占有率超过了 60% 的底气，2012年7月，开发 SPDY 的小组公开表示，它正在努力实现标准化，HTTP 坐不住了，之后互联网标准化组织**以 SPDY 为基础开始制定新版本的 HTTP 协议**，最终在 2015 年发布了 HTTP/2。

* **二进制协议**，不再是纯文本，从文本到二进制其实简化了整齐的复杂性，解析数据的开销更小，数据更加紧凑，减少了网络的延迟，**提升了整体的吞吐量**。
* 支持一个 TCP 连接发起多请求，即**支持多路复用**，移除了 pipeline，像 HTTP/1.1 pipeline 还是有阻塞的情况，需要等前面的一个响应返回了后面的才能返回，而多路复用就是完全异步化，这减少了整体的往返时间（RTT），解决了 HTTP 队头阻塞问题，也规避了 TCP 慢启动带来的影响。
* **利用 HPACK 压缩头部**，减少数据传输量，减少带宽使用。采用了静态表、动态表和哈夫曼编码，在客户端和服务器都维护请求头的列表，所以只需要增量和压缩过的头部信息，服务端拿到之后组装一下就能得到完整的头部信息。
* **允许服务端主动推送数据**，这个其实就是减少了请求的次数，比如客户端请求 1.html，我把 1.html 需要的 js 和 css 也一块送过去，省的之后客户端再请求我要 js ，我要这个 css。

&#x20;       **多路复用:** 在发送端把数据(request/response)“打碎”成`Frame`，然后在同一个 tcp connection 中传输，再在接收端把`Frame`重组。通过这种方式实现一个 connection 上承载多个`Frame`，由于 tcp connection的 `Frame` 可能来自于不同的 request/response，这样就实现了一个连接承载多个请求/响应。

![](<../../../.gitbook/assets/image (420).png>)

&#x20;       **图里面有几个概念：**

* Stream: 一个 connection 中有多个 stream，每个 stream 有唯一 ID。stream 是个逻辑上的通信通道。
* Message: 相当于一个 request 或 response
* Frame: 一个 Message 包含一个或多个 Frame，Frame 就是 http2 的最小传输单元

![](<../../../.gitbook/assets/image (405).png>)

&#x20;       请求在发送端“打碎”成 Frame，带上 stream-id `m`，当服务端响应时，每个Frame 的stream-id 均为 `m`，这样浏览器就能够重组，从而实现多路复用。

* 同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗；
* 并行交错地发送多个请求，请求之间互不影响；
* 并行交错地发送多个响应，响应之间互不干扰；
* 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。

> HTTP/2 的整体演进都是往性能优化的角度发展，因为此时的性能就是痛点，任何东西的演进都是哪里痛医哪里。

#### **1.2.6 HTTP/3**

&#x20;       HTTP/2 这么好，是不是就已经完美了呢？Google给出了否定的答案。

![](<../../../.gitbook/assets/image (181).png>)

&#x20;       TCP 是面向可靠的、有序的传输协议，因此会有失败重传和按序机制，而 HTTP/2 是所有流共享一个 TCP 连接，所以会有 TCP 层面的队头阻塞，当发生重传时会影响多个请求响应。并且 TCP 是基于四元组（源IP，源端口，目标IP，目标端口）来确定连接的，而在移动网络的情况下 IP 地址会频繁的换，这会导致反复的建连。还有 TCP 与 TLS 的叠加握手，增加了延时。**问题就出在 TCP 身上**，所以 Google 就把目光瞄向了 UDP。

&#x20;       UDP 我们知道是无连接的，不管什么顺序，也不管你什么丢包，简单的说就是 TCP 太保守了，更激进的做法，把 TCP 可靠、有序的功能提到应用层来实现，因此 Google 就研究出了 QUIC 协议。

&#x20;       实际上在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 **QUIC**，而且还是相同的“套路”，继续在 Chrome 和自家服务器里试验着“玩”，依托它的庞大用户量和数据量，持续地推动 QUIC 协议成为互联网上的“既成事实”。 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。

&#x20;       QUIC协议特性：

* QUIC协议提供类似于HTTP2的流功能
* QUIC协议使用流ID取代IP和端口，这样就能实现连接迁移。例如说从4G信号切换到wifi，下层的IP和端口变了，但是由于QUIC的流ID没有变，这个连接不会变，可以继续使用这个连接。

### 1.3 HTTP相关的协议



![](<../../../.gitbook/assets/image (192).png>)

#### **1.3.1 TCP/IP**

&#x20;       HTTP 是一个"传输协议"，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“HTTP over TCP/IP”。

![](<../../../.gitbook/assets/image (177).png>)

#### **1.3.2 DNS**

&#x20;       在 TCP/IP 协议中使用 IP 地址来标识计算机，但是数字形式的地址对于人类来说难以记忆且难以输入。于&#x662F;**“域名系统”（Domain Name System）**&#x51FA;现了，用有意义的名字来作为 IP 地址的等价替代。

&#x20;       在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。

&#x20;       HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。

![](<../../../.gitbook/assets/image (437).png>)

![](<../../../.gitbook/assets/image (260).png>)

### 1.4 URI与URL

&#x20;       在日常的说法中，我们通常在说到网址时都是以URI或URL混称，严格地说，URI 不完全等同于网址，它包含有 URL 和 URN 两个部分，在 HTTP 世界里用的网址实际上是 URL。但因为 URL 实在是太普及了，所以常常把URI与URL这两者简单地视为相等。

* **URI：Uniform Resource Identifier，统一资源标志符，唯一地标记资源的位置或者名字。**
* **URL：Uniform Resource Locator，统一资源定位符。**
* **URN：Uniform Resource Name，统一资源名。**

![](<../../../.gitbook/assets/image (190).png>)

&#x20;       **URN与URL都是URI的子集，其中URN定义某事物的身份，而URL提供查找该事物的方法**。用于标识唯一书目的[ISBN](https://zh.wikipedia.org/wiki/ISBN)系统是一个典型的URN使用范例。例如，`ISBN 0-486-27557-4`无二义性地标识出莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。为获得该资源并阅读该书，人们需要它的位置，也就是一个URL地址。在类Unix操作系统中，一个典型的URL地址可能是一个文件目录，例如`file:///home/username/RomeoAndJuliet.pdf`。该URL标识出存储于本地硬盘中的电子书文件。因此，URL和URN有着互补的作用。

&#x20;       **URI的组成格式如下：**

![](<../../../.gitbook/assets/image (476).png>)

## 2. HTTP协议的特点

为什么HTTP 协议好像也挺简单，凭什么它就能统治互联网这么多年呢？

![](<../../../.gitbook/assets/image (196).png>)

*   **灵活可扩展**

    HTTP 协议是一个“灵活可扩展”的传输协议。HTTP 协议最初诞生的时候就比较简单，本着开放的精神只规定了报文的基本格式，报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制。所以，HTTP 协议就随着互联网的发展一同成长起来了。在这个过程中，HTTP 协议逐渐增加了请求方法、版本号、状态码、头字段等特性。而 body 也不再限于文本形式的 TXT 或 HTML，而是能够传输图片、音频视频等任意数据，这些都是源于它的“灵活可扩展”的特点。
*   **可靠传输**

    HTTP 协议是一个“可靠”的传输协议，因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。
*   HTTP 协议是一个应用层的协议

    HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。
*   **请求 - 应答**

    HTTP 的请求 - 应答模式也恰好契合了传统的 C/S（Client/Server）系统架构，请求方作为客户端、应答方作为服务器。所以，随着互联网的发展就出现了 B/S（Browser/Server）架构，用轻量级的浏览器代替笨重的客户端应用，实现零维护的“瘦”客户端，而服务器则摈弃私有通信协议转而使用 HTTP 协议。此外，请求 - 应答模式也完全符合 RPC（Remote Procedure Call）的工作模式，可以把 HTTP 请求处理封装成远程函数调用，导致了 WebService、RESTful 和 gPRC 等的出现。
*   **无状态**&#x20;

    “状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些变化信息。比     如TCP 协议是有状态的，一开始处于 CLOSED 状态，连接成功后是 ESTABLISHED 状态，断开连接后是 FIN-WAIT 状态，最后又是 CLOSED 状态。

## 3. HTTP报文结构

&#x20;       HTTP 协议也是与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一&#x4E2A;**“纯文本”**&#x7684;协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。

&#x20;       HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

![](<../../../.gitbook/assets/image (187).png>)

* 起始行（start line）：描述请求或响应的基本信息；
* 头部字段集合（header）：使用 key-value 形式更详细地说明报文；
* 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

&#x20;       其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。**HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。**

### 3.1 请求行

&#x20;       请求行（request line）即请求报文里的起始行，它简要地描述了客户端想要如何操作服务器端的资源。请求行由三部分构成：

![](<../../../.gitbook/assets/image (281).png>)

**请求方法：**&#x5982; GET/POST，表示对资源的操作；

**请求路径：**&#x901A;常是一个 URI，标记了请求方法要操作的资源；

**版本号：**&#x8868;示报文使用的 HTTP 协议版本。

这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。

### 3.2 状态行

&#x20;       响应报文里的起始行即“状态行”（status line），意思是服务器响应的状态。比起请求行来说，状态行要简单一些，同样也是由三部分构成：

![](<../../../.gitbook/assets/image (3).png>)

**版本号：**&#x8868;示报文使用的 HTTP 协议版本；

**状态码：**&#x4E00;个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；

**原因：**&#x4F5C;为数字状态码补充，是更详细的解释文字，帮助理解状态原因。

### 3.3 请求方法

目前HTTP/1.1规定的8种方法：

* **GET：**&#x83B7;取资源，可以理解为读取或者下载数据；请求从服务器获取资源，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。GET 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。例如，在 URI 后使用“#”，就可以在获取页面后直接定位到某个标签所在的位置；使用 If-Modified-Since 字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；使用 Range 字段就是“范围请求”，只获取资源的一部分数据。
* **HEAD：**&#x83B7;取资源的元信息；HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，**但服务器不会返回请求的实体数据**，**只会传回响应头，也就是资源的“元信息”**。HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。
* **POST**：向资源提交数据，相当于写入或上传数据。
* **PUT：**&#x7C7B;似 POST；在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。
* **DELETE：**&#x5220;除资源；
* **CONNECT**：建立特殊的连接隧道；
* **OPTIONS：**&#x5217;出可对资源实行的方法；
* **TRACE：**&#x8FFD;踪请求 - 响应的传输路径。

### 3.4 头部

&#x20;       请求头和响应头的结构是基本一样的，唯一的区别是起始行。头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。

**请求头：**

![](<../../../.gitbook/assets/image (186).png>)

**响应头：**

![](<../../../.gitbook/assets/image (433).png>)

使用头字段需要注意下面几点：

* 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；
* 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“\_”。例如，“test-name”是合法的字段名，而“test name”“test\_name”是不正确的字段名；字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；
* 字段的顺序是没有意义的，可以任意排列不影响语义；
* 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。

## 4. HTTP状态码

&#x20;       HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。当客户端向服务器端发送请求时，借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。

状态码的类别 ：

|     |            类别           |      原因短语     |
| :-: | :---------------------: | :-----------: |
| 1xx |  Informational（信息性状态码）  |   接收的请求正在处理   |
| 2xx |      Success（成功状态码）     |    请求正常处理完毕   |
| 3xx |   Redirection（重定向状态码）   | 需要进行附加操作以完成请求 |
| 4xx | Client Error（客户端错误状态码 ） |   服务器无法处理请求   |
| 5xx |  Server Error（服务器错误状态码） |   服务器处理请求出错   |

### 4.1 2xx 成功

* **200 ok**

&#x20;       最为常见，表示从客户端发来的请求在服务器端被正常处理了。

* **204 No Content**

&#x20;       该状态码代表服务器接收的请求已成功处理，但没有资源可返回，返回的响应报文中不含实体的主体   部分。另外，**也不允许返回任何实体的主体**。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。

* **206 Partial Content**

&#x20;       该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 **Content-Range**指定范围的实体内容。比如断点续传。

### 4.2 3XX 重定向

3XX响应结果表明浏览器（客户端）需要执行某些特殊的处理以正确处理请求。

* **301 Moved Permanently**

&#x20;       **永久性重定向**。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。请求的资源已经被移动到了由Response头部**Location**字段指定的url上，是固定的不会再改变。

* **302 Found**

&#x20;       **临时性重定向**。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。 和 301 Moved Permanently 状态码相似，请求的资源已经被移动到了由Response头部**Location**字段指定的url上，但 302 状态码代表的资源不是被永久移动，只是临时性质的。由于这样的重定向是临时的，客户端应当继续向**原有地址**发送以后的请求。

* **303 See Other**

&#x20;       该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相同的功能，**但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。**

> &#x20;_当301、302、303响应状态码返回时，几乎所有浏览器都会把post改成get，并删除请求报文内的主体，之后请求会自动再次发送。 301、302标准是禁止将post方法改变成get方法的，但实际使用时大家都会这么做。_

* **304 Not Modified**

&#x20;       该状态码表示客户端发送附带条件的请求（指采用 GET方法的请求报文中包含 If-Match，If-Modified- Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部）时，**表示资源未修改，用于缓存控制**。服务器返回此状态码时，不会返回响应主体。

&#x20;       _304 虽然被划分在 3XX 类别中，但是和重定向没有关系。_

* **307 Temporary Redirect**

&#x20;       临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准 64 禁止 POST 变换成 GET，但实际使用时大家并不遵守。 307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。

### 4.3 4XX 客户端错误

* **400 Bad Request**

&#x20;       该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

* **401 Unauthorized**

&#x20;       该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示 用 户认证失败。

* **403 Forbidden**

&#x20;       该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。

* **404 Not Found**

&#x20;       该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服 务器端拒绝请求且不想说明理由时使用。

### 4.4 5XX 服务器错误

* **500 Internal Server Error**

&#x20;       该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。

* **503 Service Unavailable**

&#x20;       该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法 处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。



> **注意⚠️: 状态码和状况的不一致情况：**
>
> 不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。 比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。

## 5. HTTP首部字段

HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

* **通用字段：**&#x5728;请求头和响应头里都可以出现；
* **请求字段：**&#x4EC5;能出现在请求头里，进一步说明请求信息或者额外的附加条件；
* **响应字段：**&#x4EC5;能出现在响应头里，补充说明响应报文的信息；
* **实体字段：**&#x5B83;实际上属于通用字段，但专门描述 body 的额外信息。

### 5.1 通用首部字段（HTTP/1.1）

#### 5.1.1 Cache-Control

通过指定首部字段 Cache-Control 的指令，可以控制缓存的工作机制。

**缓存请求指令：**

|         指令        |  参数 |       说明      |
| :---------------: | :-: | :-----------: |
|     no-cache      |  无  |  强制向源服务器再次验证  |
|     no-store      |  无  | 不缓存请求或响应的任何内容 |
| max-age = \[ 秒]   |  必需 |   响应的最大Age值   |
|        ...        | ... |      ...      |

**缓存响应指令：**

|         指令        |  参数  |         说明        |
| :---------------: | :--: | :---------------: |
|      public       |  无   |    可向任意方提供响应的缓存   |
|      private      | 可省略  |     仅向特定用户返回响应    |
|     no-cache      |  可省略 |   缓存前必须先确认其有效性值   |
|     no-store      |   无  |   不缓存请求或响应的任何内容   |
|  max-age = \[ 秒]  |  必需  |     响应的最大Age值     |
| s-maxage = \[ 秒]  |  必需  |  公共缓存服务器响应的最大Age值 |
|        ...        |  ... |        ...        |

**表示是否能缓存的指令：**

**public指令：**&#x5F53;指定使用 public 指令时，则明确表明其他用户也可利用缓存。

```
Cache-Control: public
```

**private指令：**&#x5F53;指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。 缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。

```
Cache-Control: private
```

**no-cache指令:** 使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。 如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。

```
Cache-Control: no-cache
```

**控制可执行缓存的对象的指令:**

**no-store 指令:** 该指令规定缓存不能在本地存储请求或响应的任一部分

```
Cache-Control: no-store
```

#### **5**.1.2 Connection

Connection 首部字段具备如下两个作用：&#x20;

* 控制不再转发给代理的首部字段

&#x20;       在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首 部）。

![](<../../../.gitbook/assets/image (442).png>)

* **管理持久连接**

&#x20;       HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持 久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。

&#x20;      `Connection: Keep-Alive`

#### 5.1.3 Date

&#x20;       首部字段 Date 表明创建 HTTP 报文的日期和时间。

&#x20;       `Date: Tue, 03 Jul 2012 04:40:59 GMT`

#### 5.1.4 Via

&#x20;       使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文 的传输路径。 报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信 息，然后再进行转发。首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。 所以必须在经过代理时附加该首部字段内容。

![](<../../../.gitbook/assets/image (133).png>)

### 5.2 **请求首部字段**

#### 5.**2**.1 Accept

&#x20;       Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。

&#x20;       `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,`_`/`_`;q=0.8`

&#x20; 媒体类型：

* 文本文件 text/html, text/plain, text/css ... application/xhtml+xml, application/xml ...&#x20;
* 图片文件 image/jpeg, image/gif, image/png ...&#x20;
* 视频文件 video/mpeg, video/quicktime ...&#x20;
* 应用程序使用的二进制文件 application/octet-stream, application/zip ...

#### 5.**2**.2 Accept-Charset

&#x20;       Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及 字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字 段 Accept 相同的是可用权重 q 值来表示相对优先级。

&#x20;       `Accept-Charset: iso-8859-5, unicode-1-1;q=0.8`

#### 5.**2**.3 Accept-Encoding

&#x20;       Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。可一次性指定多种内容编码。

&#x20;       `Accept-Encoding: gzip, deflate`

内容编码：

* **gzip** 由文件压缩程序 gzip（GNU zip）生成的编码格式 （RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余 校验（Cyclic Redundancy Check，通称 CRC）。
* **compress** 由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel- Ziv-Welch 算法（LZW）。&#x20;
* **deflate** 组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法 （RFC1951）生成的编码格式。&#x20;
* **identity** 不执行压缩或不会变化的默认编码格式

#### 5.**2**.4 Accept-Language

&#x20;       首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然 语言集（指中文或英文等），以及自然语言集的相对优先级。可一次 指定多种自然语言集。

&#x20;       `Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3`

#### 5.**2**.5 Host

&#x20;       首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。**Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请 求内的首部字段。**

&#x20;       请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。**但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。**&#x56E0;此，就需要使用首部 字段 Host 来明确指出请求的主机名。

&#x20;       `Host: www.baidu.com`

#### 5.**2**.6 If-Match

&#x20;       If-xxx 这种样式的请求首部字段，都可称为条件请求。**服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。**

![图：只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会 接受请求](<../../../.gitbook/assets/image (411).png>)

&#x20;       服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。

#### 5.**2**.7 If-Modified-Since

&#x20;       首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If- Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。 而在指定 If-Modified-Since 字段值的日期时间之后，**如果请求的资源 都没有过更新，则返回状态码 304 Not Modified 的响应**。&#x20;

&#x20;       `If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT`

&#x20;       **If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性**。 获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。

![            图：如果在 If-Modified-Since 字段指定的日期时间后，资源发生了 更新，服务器会接受请求](<../../../.gitbook/assets/image (122).png>)

#### 5.**2.8** If-None-Match

&#x20;       首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与 请求资源的 ETag 不一致时，它就告知服务器处理该请求。 在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资 源。因此，这与使用首部字段 If-Modified-Since 时有些类似。

![图：只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理 该请求。与 If-Match 首部字段的作用相反](<../../../.gitbook/assets/image (191).png>)

#### 5.**2**.9 If-Range

&#x20;       首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If- Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。

![](<../../../.gitbook/assets/image (480).png>)

![](<../../../.gitbook/assets/image (180).png>)

#### 5.**2**.10 Range

&#x20;      `Range: bytes=5001-10000`

&#x20;       对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状 态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返 回状态码 200 OK 的响应及全部资源。

### 5.3 响应**首部字段**

#### 5.**3**.1 Accept-Ranges

&#x20;       首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。 可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则 指定其为none。

&#x20;      `Accept-Ranges: bytes`

#### 5.**3**.2 ETag

&#x20;       首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。

&#x20;       `ETag: "82e22293907ce725faf67773957acd12`

#### 5.**3**.3 Location

&#x20;       使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。 基本上，该字段会配合3xx ：Redirection 的响应，提供重定向的 URI。 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强 制性地尝试对已提示的重定向资源的访问。

&#x20;       `Location:` [`http://www.usagidesign.jp/sample.html`](http://www.usagidesign.jp/sample.html)

#### 5.**3**.4 Retry-After

&#x20;       首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使 用。字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数。

&#x20;       `Retry-After: 120`

### 5.4 实体**首部字段**

#### 5.**4**.1 Allow

&#x20;       首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支 持的 HTTP 方法写入首部字段 Allow 后返回。

&#x20;       `Allow: GET, HEAD`

#### 5.4.2 Content-Encoding

&#x20;       首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。

&#x20;     `Content-Encoding: gzip`

#### 5.&#x34;**.3** Content-Language

&#x20;       首部字段 Content-Language 会告知客户端，实体主体使用的自然语言 （指中文或英文等语言）。

&#x20;       `Content-Language: zh-CN`

#### 5.&#x34;**.4** Content-Length

&#x20;       首部字段 Content-Length 表明了实体主体部分的大小（单位是字 节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。

&#x20;       `Content-Length: 15000`

#### 5.&#x34;**.5** Content-Range

&#x20;       针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客 户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为 单位，表示当前发送部分及整个实体大小。

&#x20;       `Content-Range: bytes 5001-10000/10000`

#### 5.&#x34;**.6** Content-Type

&#x20;       首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字 段 Accept 一样，字段值用 type/subtype 形式赋值。

&#x20;       `Content-Type: text/html; charset=UTF-8`

#### 4.&#x34;**.7** Expires

&#x20;       首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接 收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过 指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求 资源。 源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写 入与首部字段 Date 相同的时间值。 但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字 段 Expires，会优先处理 max-age 指令。

&#x20;       `Expires: Wed, 04 Jul 2012 08:26:05 GM`

#### 5.&#x34;**.8** Last-Modified

&#x20;       首部字段 Last-Modified 指明资源最终修改的时间。

&#x20;       `Last-Modified: Wed, 23 May 2012 09:59:55 GMT`
