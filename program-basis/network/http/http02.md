---
description: '> HTTP专题02'
---

# HTTP进阶

> **目标：**
>
> * 对 HTTP 协议形成一个**整体概念**，明确设计 HTTP 的**目的及意义所在**，了解 HTTP 的**工作机制**。
> * 掌握HTTP报文中常用的**首部字段**，返回结果**状态码**的作用，对客户端与服务器的各种通信交互细节做到了然于心，从而在平时的开发工作中**独立思考**，迅速准确地定位分析由 HTTP 引发的问题。

## 1. HTTP缓存

### **1.1 什么是HTTP缓存 ？**

&#x20;       由于网络链路漫长，时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把“来之不易”的数据缓存起来，下次再请求的时候尽可能地复用。这样，就可以避免多次请求 - 应答的通信成本，节约网络带宽，也可以加快响应速度。

&#x20;       HTTP 缓存机制就是，配置服务器响应头来告诉浏览器是否应该缓存资源、是否强制校验缓存、缓存多长时间；浏览器根据返回的响应头判断是否应该取缓存、缓存过期、发送请求头验证缓存是否可用、还是重新获取资源的过程。

### **1.2 HTTP缓存分类**

&#x20;       根据是否需要重新向服务器发起请求来分类，可分为**强制缓存**和**协商缓存** (根据是否可以被单个或者多个用户使用来分类，也可分为私有缓存和共享缓存)。**强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。**

#### 1.2.1 强制缓存

&#x20;       强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。跟强制缓存相关的header头属性有Pragma/Cache-Control/Expires。

#### 1.2.2 协商缓存

&#x20;       当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。**跟协商缓存相关的header头属性有ETag/If-Not-Match 、Last-Modified/If-Modified-Since，请求头和响应头需要成对出现。**

&#x20;       http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。

### **1.3 缓存相关头字段**

**响应头缓存相关字段：**

|                                                                                          | (常用)值                                                                                                                                                                                                                                            | 说明                        |
| ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------- |
| [Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control) | <p>no-store, 不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；</p><p>no-cache,可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；</p><p>must-revalidate,如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。</p><p>max-age, xx秒，缓存时间</p><p>public, 其他用户也可使用缓存，适用于公共缓存服务器的情况。</p><p>private，特定用户才可以缓存。</p> | 控制浏览器是否可以缓存资源、强制缓存校验、缓存时间 |
| [ETag](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag)                   | 文件指纹（hash码、时间戳等可以标识文件是否更新）                                                                                                                                                                                                                       | 强校验，根据文件内容生成精确            |
| [Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified) | 请求的资源最近更新时间                                                                                                                                                                                                                                      | 弱校验， 根据文件修改时间，可能内容未变，不精确  |
| [Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)             | 资源缓存过期时间                                                                                                                                                                                                                                         | 与响应头中的 Date 对比            |

**请求头缓存相关字段：**

|                                                                                                  | 值                       | 说明                  |
| ------------------------------------------------------------------------------------------------ | ----------------------- | ------------------- |
| [If-None-Match](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match)         | 缓存响应头中的 ETag 值          | 发送给服务器比对文件是否更新（精确）  |
| [If-Modified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since) | 缓存响应头中的 Last-Modified 值 | 发送给服务器比对文件是否更新（不精确） |

### 1.4 缓存过程

![](<../../../.gitbook/assets/image (304).png>)

**浏览器发起请求，头部域字段的判断过程**：

1. 浏览器首先判断是否有缓存，没有则直接请求服务器。
2. 如果有缓存，会先查询`Cache-Control` (这里用`Expires`判断也是可以的，如果两者都设置了，则只有`Cache-Control`的设置生效)来判断内容是否过期，如果未过期，则直接读取浏览器端缓存文件，不发送HTTP请求，否则进入下一步。
3. 如果缓存已过期，则在浏览器端判断上次文件返回头中是否含有`Etag`信息，有则带上`If-None-Match`字段信息发送请求给服务器，服务端判断`Etag`未修改则返回304，如果修改则返回200，否则进入下一步。
4. 在浏览器端判断上次文件返回头中没有`Etag`信息，且包含有`Last-Modifed`，有则带上\
   `If-Modified-Since`字段信息发送请求，服务端判断`Last-Modified`失效则返回200， 有效则返回\
   304。
5. 如果`Etag`和`Last-Modified`都不存在，则直接向服务器请求内容。

## 2. HTTPS

### 2.1 HTTPS的概念

&#x20;       HTTPS（HyperText Transfer Protocol over Secure Socket Layer）是以安全为目标 的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL /TLS层，SSL/TLS也应用在应用层（会话层）上，只不过是给HTTP套了一层安全的壳（只要掌握SSL/TLS，也就掌握了HTTPS，SSL是TLS的前身，具体可参考[传输层安全协议](https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A)）。

&#x20;       HTTPS最初由网景公司研发，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。与HTTP默认使用80端口不同，HTTPS使用443端口。

![](<../../../.gitbook/assets/image (454).png>)

#### 2.1.1 对称加密

&#x20;       加密解密都使用同一个密钥，目前常用的只有 AES 和 ChaCha20。(在网络传输中有一个很大的问题：如何把密钥安全地传递给对方，术语&#x53EB;**“密钥交换”)。**&#x5BF9;称加密有RC4、DES、3DES、AES、ChaCha20 等

#### 2.1.2 非对称加密

&#x20;       对称加密（也叫公钥加密算法）。有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。公钥和私钥有个特别的“单向”性，**公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密**。

#### 2.1.3 混合加密

&#x20;       既然非对称加密更加安全且没有“密钥交换”的问题，是不是认为可以抛弃对称加密，只用非对称加密来实现机密性呢？很遗憾，非对称加密基于复杂的数学运算，速度很慢，即使是 ECC 也要比 AES 差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度会大大降低，实用性就变成了零。

&#x20;       TLS 里使用的混合加密方式：在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。

#### 2.1.4 数字签名与证书

&#x20;       加密算法结合摘要算法，我们的通信过程可以说是比较安全了。但这里还有漏洞，就是通信的两个端点（endpoint）。

![](<../../../.gitbook/assets/image (431).png>)

&#x20;       黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。

![](<../../../.gitbook/assets/image (115).png>)

&#x20;        **CA（Certificate Authority，证书认证机构）**&#x5C31;像网络世界里的公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。

&#x20;       CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）。知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。DV 是最低的，只是域名级别的可信，背后是谁不知道。EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站）。

**证书的签名-验签过程：**

![](<../../../.gitbook/assets/image (131).png>)

签&#x540D;**：**

* 使用签名哈希算法（指纹算法，如`sha256`）计算证书颁发者信息、证书持有者信息、证书有效期、证书持有者公钥等信息并生成证书摘要（即指纹`a`，一串散列值）；
* 颁发者使用自己的私钥对指纹加密，加密后的数据就是颁发者的数字签名`b`；
* 将数字签名`b`“附加”到数字证书上，变成一个签过名的数字证书；
* 颁发者将签过名的数字证书和公钥一起给到证书持有者。

验签：

* 使用者通过某种途径（如浏览器访问）拿到签过名的数字证书，解析后可以获得数字签名`b`和数字证书；
* 使用者使用数字证书中的指纹算法计算一遍数字证书相关内容，生成一个指纹`x`；
* 同时使用通过某些方式拿到的颁发者的公钥解密数字签名，拿到解密后的指纹`y`；
* 对比两个指纹`x`和`y`，如果相同，表明证书合法，可以信任并使用该证书中的信息（如持有者的公钥）。

&#x20;       小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是 **Root CA**，就只能自己证明自己了，这个就&#x53EB;**“自签名证书”（Self-Signed Certificate）**&#x6216;&#x8005;**“根证书”（Root Certificate）**。你必须相信，否则整个证书信任链就走不下去了。

![](<../../../.gitbook/assets/image (292).png>)

### 2.1 TLS握手过过程

![](<../../../.gitbook/assets/image (423).png>)

* 在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，也就是跟服务器“打招呼”。里面有**客户端的版本号、支持的密码套件，还有一个随机数（Client Random）**，用于后续生成会话密钥。
* 服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件。&#x20;
* 然后，服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。
* 接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。（这相当于说：“刚才我选的密码套件有点复杂，所以再给你个算法的参数，和刚才的随机数一样有用，别丢了。为了防止别人冒充，我又盖了个章。”）
* 之后是“Server Hello Done”消息，服务器说：“我的信息就是这些，打招呼完毕。”

这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params。

* 客户端这时也拿到了服务器的证书，然后验证证书有效性。
* 然后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。
* 现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫“Pre-Master”，其实也是一个随机数。
* 客户端发一个“Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。意思就是告诉服务器：“后面都改用对称算法加密通信了啊，用的就是打招呼时说的 AES，加密对不对还得你测一下。
* ”服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。

> 为什么会有三个随机数？
>
> &#x20;TLS 的设计者考虑得非常周到了，他们不信任客户端或服务器伪随机数的可靠性，为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测。
