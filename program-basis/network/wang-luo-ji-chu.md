# 网络基础

### 1. 网络分层

#### 1.1 OSI参考模型

&#x20;       **OSI模型**（**O**pen **S**ystem **I**nterconnection Model，**开放式系统互联模型**）是一种[概念模型](https://zh.wikipedia.org/wiki/%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B)，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。

* **物理层(Physical)**：网络传输的物理媒体部分，比如**网卡，网线，集线器，中继器，调制解调器**等，为数据传输提供可靠的物理环境。在这一层，数据还没有被组织，仅作为原始的位流或电气电压处理，这一层的单位是**bit比特**。
* **数据链路层(Datalink)**：可以理解为数据通道，主要功能是如何在不可靠的物理线路上进行数据的可靠传递，该层作用包括：物理地址寻址，数据的成帧，流量控制，数据检错以及重发等。 另外**数据链路**指的是：物理层要为终端设备间的数据通信提供传输媒体及其连接。媒体是长期的，连接是有生存期的。在连接生存期内，收发两端可以进行不等的一次或多次数据通信。 每次通信都要经过建立通信联络和拆除通信联络两过程。该层的设备有：**网卡，网桥，网路交换机**，该层的单位为**帧**。
* **网络层(Network)：**&#x4E3B;要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，所谓的**路由与寻径**：一台终端可能需要与多台终端通信，这样就产生的了把任意两台终端设备数据链接起来的问题，简单说就是建立网络连接和为上层提供服务。该层的设备有：**路由**。该层的单位为**数据包**。
* **传输层(Transport)**：向上面的应用层提供通信服务，面向通信部分的最高层，同时也是用户功能中的最低层。接收会话层数据，在必要时将数据进行分割，并将这些数据交给网络层，并且保证这些数据段有效的到达对端。该层的单位是**数据段。**
* **会话层(Session)**：负责在网络中的两节点之间建立、维持和终止通信。建立通信链接， 保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送，即不同机器上的用户之间会话的建立及管理。
* **表示层(Presentation)**：对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是"处理用户信息的表示问题，如编码、 数据格式转换和加密解密，压缩解压缩"等。
* **应用层(Application)**：OSI参考模型的最高层，为用户的应用程序提供网络服务。 它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。

#### 1.2 TCP/IP

&#x20;       TCP/IP是指TCP/IP协议簇的集合。与 TCP/IP协议簇分为四层：

![](<../../.gitbook/assets/image (116).png>)

* **应用层**：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、 网络远程访问协议（Telnet）等。
* **传输层**：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、 用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中， 这一层负责传送数据，并且确定数据已被送达并接收。
* **网络层** ：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目 的主机（但不检查是否被正确接收），如网际协议（IP）。
* **数据链路层**：定义如何使用实际网络 （如Ethernet、Serial Line等）来传送数据。

TCP/IP分层与OSI分层的对应关系如下：

![](<../../.gitbook/assets/image (490).png>)



&#x20;       两个因特网主机通过两个路由器和对应的层连接。各主机上的应用通过一些数据通道相互执行读取操作。

![](<../../.gitbook/assets/image (463).png>)

&#x20;       沿着不同的层应用数据的封装。

![](<../../.gitbook/assets/image (175).png>)

### 2. IP地址与端口

#### 2.1 IP地址

&#x20;       **IP地址**（IP Address，全称Internet Protocol Address），又译为**网际协议地址**、**互联网协议地址**。当设备连接网络，设备将被分配一个IP地址，用作标识。通过IP地址，设备间可以互相通讯，如果没有IP地址，我们将无法知道哪个设备是发送方，无法知道哪个是接收方。

&#x20;       常见的IP地址分为 [IPv4](https://zh.wikipedia.org/wiki/IPv4) 与 [IPv6](https://zh.wikipedia.org/wiki/IPv6) 两大类，IP地址由一串数字组成。IPv4 由十进制数字组成，并以点分隔，如：`172.16.254.1` ； IPv6 由十六进制数字组成，以冒号分割，如：`2001:db8:0:1234:0:567:8:1`

&#x20;       IP地址有两个主要的功能：

* **标识主机**。标识主机网络接口，提供主机在网络中的位置。
* **网络寻址**。IP协议的一个重要机制就是网络寻址（internet address）。该功能的目的是将 数据报 从一个网络模块 送到目的地。在发送的整个过程，IP地址（address）充当着目的地的位置，[路由](https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1)（route）代表着如何到达目的地的这个过程。每个[IP数据包](https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE)的标头包含了发送主机的IP地址和目的主机的IP地址。

#### 2.2 端口

&#x20;       面向连接服务TCP协议和无连接服务UDP协议使用16bits端口号来表示和区别网络中的不同应用程序。如果把IP地址比作一间房子 ，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口可以有65536（即：2^16）个之多。

&#x20;       端口号规定为16位，即允许一个IP主机有2的16次方65535个不同的端口。其中：

*   0\~1023：分配给系统的端口号

    > 不可自定义使用 常用协议使用的端口：HTTP:80，HTTPS：443，FTP：21，TELNET：23
*   1024\~49151：登记端口号，主要是让第三方应用使用

    > 但是必须在IANA（互联网数字分配机构）按照规定手续登记，
* 49152\~65535：短暂端口号，是留给客户进程选择暂时使用，一个进程使用完就可以供其他进程使用。

### 3. TCP与UDP

#### 3.1 TCP

&#x20;       **传输控制协议**（**T**ransmission **C**ontrol **P**rotocol，缩写：**TCP**）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的[RFC](https://zh.wikipedia.org/wiki/RFC) [793](https://tools.ietf.org/html/rfc793)定义。基于TCP的应用层协议有FTP、Telnet、SMTP、HTTP、POP3与DNS等。

&#x20;       特点：面向连接、面向字节流、全双工通信、可靠。

* **面向连接**：指的是要使用TCP传输数据，必须先建立TCP连接，传输完成后释放连接，就像打电话一样必须先拨号建立一条连接，打完后挂机释放连接。
* **全双工通信**：即一旦建立了TCP连接，通信双方可以在任何时候都能发送数据。
* **可靠的**：指的是通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。
* **面向字节流**：流，指的是流入到进程或从进程流出的字符序列。简单来说，虽然有时候要传输的数据流太大，TCP报文长度有限制，不能一次传输完，要把它分为好几个数据块，但是由于可靠性保证，接收方可以按顺序接收数据块然后重新组成分块之前的数据流，所以TCP看起来就像直接互相传输字节流一样，面向字节流。

![](<../../.gitbook/assets/image (141).png>)

* 来源连接端口（16位长）－识别发送连接端口
* 目的连接端口（16位长）－识别接收连接端口
* 序列号（seq，32位长）
  * 如果含有同步化旗标（SYN），则此为最初的序列号；第一个资料比特的序列码为本序列号加一。
  * 如果没有同步化旗标（SYN），则此为第一个资料比特的序列码。
* 确认号（ack，32位长）—期望收到的数据的开始序列号。也即已经收到的数据的字节长度加1。



![](<../../.gitbook/assets/image (351).png>)

**三次握手**

1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN\_SEND状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN\_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

**四次挥手**

1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN\_WAIT\_1状态；这表示主机1没有数据要发送给主机2了；
2. 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN\_WAIT\_2状态；主机2告诉主机1，我“同意”你的关闭请求；
3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST\_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME\_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。
