# JVM运行时数据区

&#x20;       Java 虚拟机定义了程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，随着线程开始和结束而创建和销毁。

* 线程私有：程序计数器、栈、本地栈
* 线程共享：堆、堆外内存（永久代或元空间、代码缓存）

![JVM整体结构](<../../../.gitbook/assets/image (467).png>)

### 1. 运行时数据区

![](<../../../.gitbook/assets/image (253).png>)

#### 1.1 程序计数器

&#x20;       程序计数寄存器（**Program Counter Register**），是一块较小的内存区域，可以看作是当前线程所执行的字节码的**行号指示器。**&#x52;egister 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。**JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟**。

* 它是一块很小的内存空间，大小几乎可以忽略不计，也是运行速度最快的存储区域。
* **Java虚拟机规范中，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，它的生命周期与线程相同。**
* 任何时刻一个线程都只有一个方法在执行，即**当前方法**。如果当前线程正在执行的是Java 方法，程序计数器记录的是 JVM 字节码指令地址，**如果是执行 native 方法，则是未指定值undefined**。
* 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
* 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
* **它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域**。

‍        为什么使用PC寄存器记录当前线程的执行地址呢？ ‍因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。 ‍

&#x20;       PC寄存器为什么会被设定为线程私有的？ ‍多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。

#### 1.2 虚拟机栈

&#x20;       与程序计数器一样，**Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。**&#x865A;拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储**局部变量表**、**操作数栈**、**动态连接、方法出口**等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用，则出栈。所有的栈帧都出栈后，线程也就结束了。

![](<../../../.gitbook/assets/image (171).png>)

* 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
* JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着**入栈**（进栈/压栈），方法执行结束**出栈。**
* **栈不存在垃圾回收问题。**
* 在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：**如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常**；如果Java虚拟机栈容量可以动态扩展，当栈扩 展时无法申请到足够的内存会抛出OutOfMemoryError异常。
* 可以通过参数-Xss来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。

&#x20;**栈帧：**

&#x20;       每个线程都有自己的栈，栈中的数据都是以**栈帧（Stack Frame）**&#x7684;格式存&#x5728;**。**&#x5728;一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（**栈顶栈帧**）是有效的，这个栈帧被称为**当前栈帧**（Current Frame），与当前栈帧对应的方法就是**当前方法**（Current Method），定义这个方法的类就是**当前类**（Current Class）。

* Java 方法有两种返回函数的方式，**一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出**
* 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
* 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧
* 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧
* 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧

&#x20;       每个栈帧（Stack Frame）中存储着：

* 局部变量表（Local Variables）
* 操作数栈（Operand Stack）(或称为表达式栈)
* 动态链接（Dynamic Linking）：指向运行时常量池的方法引用
* 方法返回地址（Return Address）：方法正常退出或异常退出的地址
* 一些附加信息

![](<../../../.gitbook/assets/image (429).png>)

**操作数栈：**

&#x20;       **主要用于保存计算过程的中间结果**，同时作为计算过程中变量临时的存储空间。操作数栈是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，**此时这个方法的操作数栈是空的，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop），**&#x67D0;些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作。

> ⚠️ JVM是基于栈的执行引擎，其中所指的栈就是操作数栈。

#### &#x20; 动态链接（指向运行时常量池的方法引用）：

&#x20;       **每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用**。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为**符号引用**（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。**

![](<../../../.gitbook/assets/image (434).png>)

#### &#x20;       JVM 是如何执行方法调用的？

&#x20;       Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class文件里面存储的都是**符号引用**，而不是方法在实际运行时内存布局中的入口地址（**直接引用**）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。

&#x20;       在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关

* 静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的**目标方法在编译期可知**，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
* 动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接

#### 1.3 本地方法栈

&#x20;       本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。**与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常。**

* 本地方法栈也是线程私有的，允许线程固定或者可动态扩展的内存大小。
* 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个OutofMemoryError异常。
* 它的具体做法是 Mative Method Stack 中登记native方法，在 Execution Engine 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。

#### 1.4 Java堆

&#x20;       **Java堆（Java Heap）是虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。**&#x6B64;内存区域的唯一目的就是存放对象实例，Java 世界&#x91CC;**“几乎”**&#x6240;有的**对象实例及数组**都在这里分配内存。

> 在《Java虚拟机规范》中对Java堆的描述是：“所有 的对象实例以及数组都应当在堆上分配”，写的“几乎”是指从实现角度来看，随着Java语 言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编 译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换\[2]优化手段已经导致一些微妙 的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。

&#x20;       由于现代垃圾收集器大部分都是基于分代收集理论设计的，主流的HotSpot虚拟机把堆内存**逻辑上**划分成三块区域（分代的唯一理由就是优化 GC 性能）：

* **新生带（年轻代）**：新对象和没达到一定年龄的对象都在新生代。
* **老年代（养老区）**：被长时间使用的对象，老年代的内存空间应该要比年轻代更大。
* **元空间（JDK1.8之前叫永久代）**：像一些方法中的操作临时对象等，JDK1.8之前是占用JVM内存，JDK1.8之后直接使用物理内存。

> 在十年之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部都基于“经典分代”来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还 算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出 现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。

&#x20;       Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 -Xmx 和 -Xms 来设定

* -Xms 用来表示堆的起始内存，等价于 -XX:InitialHeapSize
* -Xmx 用来表示堆的最大内存，等价于 -XX:MaxHeapSize

如果堆的内存大小超过 -Xmx 设定的最大内存，就会抛出 OutOfMemoryError 异常。

#### 1.5 方法区

&#x20;       方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫&#x4F5C;**“非堆”（Non-Heap）**，目的是与Java堆区分开来。

> 《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。

&#x20;       根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。

![](<../../../.gitbook/assets/image (105).png>)

&#x20;       **方法区（method area）**&#x4A;VM规范中并没有规定如何去实现它，不同的厂商有不同的实现。而**永久代（PermGen）是 Hotspot 虚拟机特有的概念， 在Java8 的时候又被元空间取代了**，永久代和元空间都可以理解为方法区的落地实现。

* 永久代是物理堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）
* 存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中
* JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）。

#### 类型信息：

对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息

* 这个类型的完整有效名称（全名=包名.类名）
* 这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）
* 这个类型的修饰符（public，abstract，final 的某个子集）
* 这个类型直接接口的一个有序列表

#### 域（Field）信息：

* JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序
* 域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）

#### 方法（Method）信息：

JVM 必须保存所有方法的

* 方法名称
* 方法的返回类型
* 方法参数的数量和类型
* 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）
* 方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）
* 异常表（abstract 和 native 方法除外）
* 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

**栈、堆、方法区的交互关系：**

![](<../../../.gitbook/assets/image (1).png>)

#### 1.6 运行时常量池

&#x20;       运行时常量池（Runtime Constant Pool）是方法区的一部分。

&#x20;       理解运行时常量池，需要先了解一下码文件（Class 文件）中的常量池（常量池表）。在一个有效的字节码文件中，除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息，那就是常量池表（Constant Pool Table），**它包含各种字面量和对类型、域和方法的符号引用**。

![](<../../../.gitbook/assets/image (446).png>)

&#x20;       **常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。**

* 在加载类到虚拟机后，就会创建对应的运行时常量&#x6C60;**。**
* **常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。**
* JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
* 运行时常量池中包含各种不同的常量，**包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。**
* 运行时常量池，相对于 Class 文件常量池的另一个重要特征是：**动态性**，Java 语言并不要求常量一定只有编译期间才能产生，**运行期间也可以将新的常量放入池中，String 类的 intern() 方法就是这样的。**
* 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。

#### 1.7 直接内存

&#x20;       直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。

&#x20;       在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。

![](<../../../.gitbook/assets/image (189).png>)

&#x20;       本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常。

### 2. 方法区的演进

在HotSpot中才有永久代的概念：

| JDK版本     | 永久代                                            |
| --------- | ---------------------------------------------- |
| JDK1.6及之前 | 有永久代                                           |
| JDK1.7    | 有永久代，但已经逐步去永久代，移除字符串常量池、静态变量到堆中。               |
| JDK1.8    | 取消永久代，类型信息，字段、方法、常量保存在本地内存的元空间，字符串常量池、静态变量仍在堆中 |

移除永久代的原因：[http://openjdk.java.net/jeps/122](http://openjdk.java.net/jeps/122)

* 为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制
* 对永久代进行调优较困难

### 3. 参考资料

* 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）
* [Java Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html)

