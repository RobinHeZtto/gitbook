# JVM对象分配与垃圾回收

### 1. 对象的分配

#### 对象的内存布局：

在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：**对象头（Header）**、**实例数据（Instance Data）**&#x548C;**对齐填充（Padding）**。

![](<../../../.gitbook/assets/image (174).png>)

**Mark Word：**&#x48;otSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特。

**Class Pointer：**&#x7C7B;型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。

#### **对象的访问：**

堆 - 栈 - 方法区

![](<../../../.gitbook/assets/image (146).png>)

#### 对象分配过程：

![](<../../../.gitbook/assets/image (276).png>)

**为什么需要Survivor区?只有Eden不行吗？减少Full GC**

　　如果没有Survivor,Eden区每进行一次Minor GC ,并且没有年龄限制的话， 存活的对象就会被送到老年代。这样一来，老年代很快被填满,触发Major GC(因为Major GC一般伴随着Minor GC,也可以看做触发了Full GC)。老年代的内存空间远大于新生代,进行一次Full GC消耗的时间比Minor GC长得多。执行时间长有什么坏处?频发的Full GC消耗的时间很长,会影响大型程序的执行和响应速度。可能你会说，那就对老年代的空间进行增加或者较少咯。假如增加老年代空间，更多存活对象才能填满老年代。虽然降低Full GC频率，但是随着老年代空间加大,一旦发生FullGC,执行所需要的时间更长。假如减少老年代空间，虽然Full GC所需时间减少，但是老年代很快被存活对象填满,Full GC频率增加。所以Survivor的存在意义,就是减少被送到老年代的对象,进而减少Full GC的发生,Survivor的预筛选保证,只有经历16次(默认第16次就去老年代)Minor GC还能在新生代中存活的对象,才会被送到老年代。

#### 为什么需要两个Survivor区？去碎片化（就是整理一下，排排坐）

　　最大的好处就是解决了碎片化。也就是说为什么一个Survivor区不行?第一部分中,我们知道了必须设置Survivor区。假设现在只有一个Survivor区,我们来模拟一下流程:刚刚新建的对象在Eden中,一旦Eden满了,触发一次Minor GC,Eden中的存活对象就会被移动到Survivor区。这样继续循环下去,下一次Eden满了的时候,问题来了,此时进行Minor GC,Eden和Survivor各有一些存活对象,如果此时把Eden区的存活对象硬放到Survivor区,很明显这两部分对象所占有的内存是不连续的,也就导致了内存碎片化。永远有一个Survivor space是空的,另一个非空的Survivor space无碎片。

#### 新生代中Eden:S1:S2为什么是8:1:1？

　　GC是统计学测算出当内存使用超过98%以上时，内存就应该被minor gc时回收一次。但是实际应用中，我们不能较真的只给 他们留下2%，换句话说当内存使用达到98%时才GC 就有点晚了，应该是多一些预留10%内存空间，这预留下来的空间我们称为S区（有两个s区  s1 和  s0），S区是用来存储新生代GC后存活下来的对象，大多数的对象都是朝生夕死，生命周期短(大多是web应用，比如一个订单下好了，就好了)。而我们知道新生代GC算法使用的是复制回收算法。所以我们实际GC发生是在，新生代内存使用达到90%时开始进行，复制存活的对象到S1区，要知道GC结束后在S1区活下来的对象，需要放回给S0区，也就是对调(对调是指，两个S区位置互换,意味着再一次minor gc 时的区域 是eden 加上一次存活的对象放入的S区)，既然能对调，其实就是两个区域一般大。这也是为什么会再有个10%的S0区域出来。这样比例就是8:1:1了 ，这里的eden区（80%） 和其中的一个  S区（10%） 合起来共占据90%，GC就是清理的他们，始终保持着其中一个  S  区是空留的，保证GC的时候复制存活的对象有个存储的地方。

### 2. 对象的生命周期

Java代码编译后生成的字节码.class文件从从文件系统中加载到虚拟机之后，便有了JVM上的Java对象，Java对象在JVM上运行有7个阶段，如下：

![](<../../../.gitbook/assets/image (443).png>)

#### **1 Created（创建）**

Java对象的创建分为如下几步：

* 1、为对象分配存储空间。
* 2、构造对象。
* 3、从超类到子类对static成员进行初始化，类的static成员的初始化在ClassLoader加载该类时进行。
* 4、超类成员变量按顺序初始化，递归调用超类的构造方法。
* 5、子类成员变量按顺序初始化，一旦对象被创建，子类构造方法就调用该对象并为某些变量赋值。

#### **2）InUse（应用）**

此时对象**至少被一个强引用持有**。

#### **3）Invisible（不可见）**

当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该对象仍然是存在的。简单的例子就是**程序的执行已经超出了该对象的作用域**了。但是，该对象**仍可能被虚拟机下的某些已装载的静态变量线程或JNI等强引用持有**，这些**特殊的强引用称为“GC Root”**。**被这些GC Root强引用的对象会导致该对象的内存泄漏，因而无法被GC回收**。

#### **4）Unreachable（不可达）**

该对象**不再被任何强引用持有**。

#### **5）Collected（收集）**

当**GC已经对该对象的内存空间重新分配做好准备**时，对象进入收集阶段，如果该对象重写了finalize()方法，则执行它。

#### **6）Finalized（终结）**

**等待垃圾回收器回收该对象空间**。

#### **7）Deallocated（对象空间重新分配）**

GC对该对象所占用的内存空间**进行回收或者再分配**，则该对象彻底消失。

#### 注意

* 1、不需要使用该对象时，及时置空。
* 2、访问本地变量优于访问类中的变量。

### 3. 引用

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。 在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

#### 强引用

就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

#### 软引用

是用来描述一些还有用但并非必需的对象。**对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收**。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。第一次GC之后再分配失败说明可能内存空间不够大，这时需要增加内存把Dalvik虚拟机的内存大小设置为启动时指定的Java堆最大值，然后再进行分配。如果在设置为最大内存后仍然失败，说明可能是要不行了，再次GC，这次要把软引用回收了。这次GC之后再进行分配，如果失败就是真的失败了。

#### 弱引用

也是用来描述非必需对象的，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能生存到下一次垃圾收集发生之前**。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。

#### 虚引用

也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。

### 4. 垃圾回收

垃圾回收主要需要解决下面三个问题：

* 哪些内存需要回收？&#x20;
* 什么时候回收？&#x20;
* 如何回收？

#### 3.1 哪些内存需要回收？

**引用计数（**&#x52;eference Countin&#x67;**）：**\
在对象中添加一个引用计数器，每当有一个地方 引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

**可达性分析**（Reachability Analysis）：\
通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。**当前主流语言内存管理子系统都是采用该方案。**

![](<../../../.gitbook/assets/image (427).png>)

在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：&#x20;

* 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。 ·在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
* 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
* 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。&#x20;
* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。&#x20;
* 所有被同步锁（synchronized关键字）持有的对象。&#x20;
* 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

#### 3.2 垃圾回收算法：

**1.Mark-Sweep（标记-清除）算法**

是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。具体过程如下图所示：&#x20;

![1](https://lh3.googleusercontent.com/-P33nYniilbY/WFjZPftupRI/AAAAAAAADGU/HS1Zlgdcwm4/I/1.jpg)

从图中可以很容易看出标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。

**在Android中通过引用LOS和前后台不同的回收算法来处理碎片内存问题。**

**2.Copying（复制）算法**

为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：&#x20;

![2](https://lh3.googleusercontent.com/-X9-_T1NOGAE/WFjZPpHXLLI/AAAAAAAADGY/CljHlKUXPUQ/I/2.jpg)

这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。

很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。

**Mark-Compact（标记-压缩）算法**

为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：

![3](https://lh3.googleusercontent.com/-HExe8E6MFFo/WFjZQHG_2yI/AAAAAAAADGc/I9RtKiI_OzY/I/3.jpg)

**在Android的ART虚拟机中，应用程序在前台运行时，响应性是最重要的，因此也要求执行的GC是高效的。相反，应用程序在后台运行时，响应性不是最重要的，这时候就适合用来解决堆的内存碎片问题。因此，Mark-Sweep GC适合作为Foreground GC，而Compacting GC适合作为Background GC。**

**3.Generational Collection（分代收集）算法**

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间（一般为8:1:1），每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。

而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。
