---
description: IOC
---

# IoC设计原则

### 1. 什么是IoC？

&#x20;       [**IoC(Inversion of Control)**](https://zh.m.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)，控制反转，是面向对象编程中的一种[**设计原则**](https://zh.m.wikipedia.org/zh-hans/SOLID_\(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1\))。

&#x20;       大多数应用程序都是由两个或是更多的类通过彼此的合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现（比如说对象内部new出依赖对象），那么这将导致代码高度耦合并且难以维护和调试。**在Ioc设计思想中，依赖对象的获取过程交由容器负责，而不是传统的直接在目标对象内部直接控制。**

![](<../../../.gitbook/assets/image (156).png>)

* **控制：**&#x4F9D;赖对象的获取由容器控制。
* **反转：**&#x83B7;取依赖对象的过程被反转。

### 2. IoC能做什么？

&#x20;       **IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则**，它能指导我们如何设计出松耦合、更优良的程序。IoC 对编程带来的最大改变不是从代码上，而是从思想上，发生&#x4E86;**“主从换位”**&#x7684;变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IoC/DI 思想中，应用程序就变成被动的了，被动的等待 IoC 容器来创建并注入它所需要的资源了。有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样更方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。

&#x20;       IoC在编程过程中不会对业务对象构成很强的侵入性，使用IoC之后，对象具有更好的可实行性，可重用性和可扩展性：

* 降低组件之间的耦合度
* 提高开发效率和产品质量
* 统一标准，提高模块的复用性
* 模块具有热插拔特性

### 3. 实现方法

&#x20;       实现控制反转主要有两种方式：**依赖注入**和**依赖查找**。两者的区别在于，前者是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。

#### 3.1 依赖注入

依赖注入有如下实现方式：

* 基于接口。实现特定接口以供外部容器注入所依赖类型的对象。
* 基于 set 方法。实现特定属性的public set方法，来让外部容器调用传入所依赖类型的对象。
* 基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。
* 基于注解。基于Java的注解功能，在私有变量前加“@Autowired”等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。该方案相当于定义了public的set方法，但是因为没有真正的set方法，从而不会为了实现依赖注入导致暴露了不该暴露的接口（因为set方法只想让容器访问来注入而并不希望其他依赖此类的对象访问）。

#### 3.2 依赖查找

&#x20;       依赖查找的大体思路是：容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象。这种方式虽然降低了对象间的依赖，但是同时也使用到了容器的 API，造成了我们无法在容器外使用和测试对象。依赖查找是一种更加传统的 IOC 实现方式。
